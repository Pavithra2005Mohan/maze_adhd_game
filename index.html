<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Runner AI with Firebase</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #F3F4F6; overflow: hidden; }
        #game-container { width: 100vw; height: 100vh; display: none; position: fixed; top: 0; left: 0; }
        .hud { position: fixed; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; align-items: flex-start; z-index: 10; pointer-events: none; }
        .hud-info { text-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        #hint-button-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 12;
        }
        #hint-button { pointer-events: all; background-color: rgba(0, 255, 255, 0.2); border: 1px solid rgba(0, 255, 255, 0.7); padding: 0.5rem 1rem; border-radius: 0.5rem; transition: all 0.2s; }
        #hint-button:hover { background-color: rgba(0, 255, 255, 0.4); }
        #hint-button:disabled { background-color: rgba(100, 100, 100, 0.2); border-color: rgba(100, 100, 100, 0.5); color: #9CA3AF; cursor: not-allowed; }
        #hint-display { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background-color: rgba(17, 24, 39, 0.8); padding: 1rem; border-radius: 0.5rem; border: 1px solid rgba(0, 255, 255, 0.5); z-index: 25; text-align: center; max-width: 80%; opacity: 0; transition: opacity 0.5s; pointer-events: none; }
        #minimap-container { position: fixed; top: 20px; right: 20px; border: 2px solid rgba(0, 255, 255, 0.5); background-color: rgba(17, 24, 39, 0.75); border-radius: 8px; padding: 5px; z-index: 11; }
        #minimap { display: block; }
        .modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(17, 24, 39, 0.95); padding: 2rem; border-radius: 1rem; border: 1px solid rgba(0, 255, 255, 0.5); box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); text-align: center; z-index: 20; display: none; width: 90%; max-width: 400px; }
        .modal-input { width: 100%; background-color: #374151; border: 1px solid #4B5563; color: white; padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 1rem; }
        .modal-button { width: 100%; padding: 0.75rem; border-radius: 0.5rem; font-weight: bold; transition: background-color 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .modal-button-primary { background-color: #06B6D4; color: white; }
        .modal-button-primary:hover { background-color: #0891B2; }
        .modal-button-secondary { background-color: transparent; border: 1px solid #06B6D4; color: #06B6D4; margin-top: 0.5rem; }
        .modal-button-secondary:hover { background-color: rgba(6, 182, 212, 0.1); }
        .modal-button-google { background-color: #DB4437; color: white; margin-top: 1rem; }
        .modal-button-google:hover { background-color: #C33D2E; }
        #auth-error { color: #F87171; margin-top: 1rem; display: none; min-height: 1.5rem; }
        .auth-view { display: none; } /* Hide auth views by default */
        .auth-view.active { display: block; }
        .auth-toggle-link { color: #06B6D4; cursor: pointer; text-decoration: underline; margin-top: 1rem; display: block; }
        .touch-controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; z-index: 15; gap: 1rem; }
        .touch-btn { width: 60px; height: 60px; background-color: rgba(0, 255, 255, 0.2); border: 2px solid rgba(0, 255, 255, 0.7); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; user-select: none; }
        @media (hover: none) and (pointer: coarse) { .touch-controls { display: flex; } }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="game-container"></div>

    <div class="hud">
        <div class="hud-info">
            <div id="level-display" class="text-2xl font-bold">Level: 1</div>
            <div id="time-display" class="text-2xl font-bold">Time: 0s</div>
        </div>
    </div>
    
    <div id="hint-button-container">
        <button id="hint-button">Get Hint ✨</button>
    </div>

    <div id="hint-display"></div>

    <div id="minimap-container">
        <canvas id="minimap"></canvas>
    </div>

    <div id="level-complete-modal" class="modal">
        <h2 id="message-title" class="text-3xl font-bold mb-4">Level Complete!</h2>
        <p id="message-text" class="mb-2"></p>
        <p id="score-text" class="text-xl font-bold text-yellow-300"></p>
        <p id="total-score-text" class="text-2xl font-bold text-yellow-400 mb-4"></p>
        <p id="ai-analysis-text" class="text-cyan-300 italic"></p>
        <button id="start-button" class="modal-button modal-button-primary mt-6">Start Next Level</button>
    </div>

    <!-- Auth Modal -->
    <div id="auth-modal" class="modal">
        <!-- Login View -->
        <div id="login-view" class="auth-view active">
            <h2 class="text-3xl font-bold mb-6">Player Login</h2>
            <input type="email" id="login-email" placeholder="Email" class="modal-input">
            <input type="password" id="login-password" placeholder="Password" class="modal-input">
            <button id="login-button" class="modal-button modal-button-primary">Login</button>
            <span class="auth-toggle-link" data-target="signup-view">Need an account? Sign Up</span>
        </div>

        <!-- Signup View -->
        <div id="signup-view" class="auth-view">
            <h2 class="text-3xl font-bold mb-6">Create Account</h2>
            <input type="text" id="signup-name" placeholder="Name" class="modal-input">
            <input type="number" id="signup-age" placeholder="Age" class="modal-input">
            <select id="signup-gender" class="modal-input">
                <option value="" disabled selected>Select Gender</option>
                <option value="male">Male</option>
                <option value="female">Female</option>
                <option value="non-binary">Non-binary</option>
                <option value="prefer-not-to-say">Prefer not to say</option>
            </select>
            <input type="email" id="signup-email" placeholder="Email" class="modal-input">
            <input type="password" id="signup-password" placeholder="Password" class="modal-input">
            <button id="signup-button" class="modal-button modal-button-primary">Create Account</button>
            <span class="auth-toggle-link" data-target="login-view">Already have an account? Login</span>
        </div>

        <!-- Common Auth Elements -->
        <div class="relative flex py-4 items-center">
            <div class="flex-grow border-t border-gray-600"></div>
            <span class="flex-shrink mx-4 text-gray-400">OR</span>
            <div class="flex-grow border-t border-gray-600"></div>
        </div>
        <button id="google-login-button" class="modal-button modal-button-google">
            <svg class="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 18 19"><path fill-rule="evenodd" d="M8.842 18.083a8.8 8.8 0 0 1-8.65-8.948 8.841 8.841 0 0 1 8.8-8.652h.153a8.464 8.464 0 0 1 5.7 2.257l-2.193 2.038A5.27 5.27 0 0 0 9.09 3.4a5.882 5.882 0 0 0-.2 11.76h.124a5.091 5.091 0 0 0 5.248-4.057L14.3 11H9V8h8.342A8.8 8.8 0 0 1 8.842 18.083Z" clip-rule="evenodd"/></svg>
            Sign in with Google
        </button>
        <p id="auth-error"></p>
    </div>

    <div class="touch-controls">
        <div id="touch-up" class="touch-btn">▲</div>
        <div id="touch-left" class="touch-btn">◄</div>
        <div id="touch-down" class="touch-btn">▼</div>
        <div id="touch-right" class="touch-btn">►</div>
    </div>

    <script type="module">
        // --- Firebase Libraries ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Firebase Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyCPxzRMVf1LhRBRoxlhGmEklTlXUIN8InU",
            authDomain: "mazerun-c6bd4.firebaseapp.com",
            projectId: "mazerun-c6bd4",
            storageBucket: "mazerun-c6bd4.firebasestorage.app",
            messagingSenderId: "926208962870",
            appId: "1:926208962870:web:152b0d9142e31012c3c397",
            measurementId: "G-84NWJ7YPT3"
        };

        // --- Firebase Initialization ---
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log("Firebase initialized successfully.");
        } catch (e) {
            console.error("Firebase initialization failed. Please check your config.", e);
            alert("Firebase is not configured correctly. Please check the script.");
        }

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const levelDisplay = document.getElementById('level-display');
        const timeDisplay = document.getElementById('time-display');
        const levelCompleteModal = document.getElementById('level-complete-modal');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const scoreText = document.getElementById('score-text');
        const totalScoreText = document.getElementById('total-score-text');
        const aiAnalysisText = document.getElementById('ai-analysis-text');
        const startButton = document.getElementById('start-button');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const hintButton = document.getElementById('hint-button');
        const hintDisplay = document.getElementById('hint-display');
        const authModal = document.getElementById('auth-modal');
        const authError = document.getElementById('auth-error');
        const authToggleLinks = document.querySelectorAll('.auth-toggle-link');

        // --- Game State ---
        let scene, camera, renderer, player, clock;
        let maze, mazeMesh, endGoal, endPos;
        let level = 1, totalScore = 0, hintsUsed = 0, powerupsCollected = 0;
        let gameActive = false, timerInterval, elapsedTime = 0;
        let wallTexture, floorTexture, currentUser = null, gameInitialized = false;
        let powerups = [];

        // --- Game Constants ---
        const WALL_HEIGHT = 5, INITIAL_PLAYER_SPEED = 5.0, MAX_PLAYER_SPEED = 10.0, PLAYER_ACCELERATION = 2.5;
        const PLAYER_TURN_SPEED = Math.PI * 0.5;
        const PLAYER_RADIUS = 0.5, CELL_SIZE = 5, MINIMAP_CELL_SIZE = 5, HINT_COOLDOWN = 15000;
        const POWERUP_COUNT = 5, POWERUP_SCORE = 50;

        // --- Player State ---
        const keyboard = {};
        let playerDirection = new THREE.Vector3(0, 0, -1);
        let currentSpeed = INITIAL_PLAYER_SPEED;

        // --- Gemini API Function ---
        async function callGemini(prompt) {
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]) return result.candidates[0].content.parts[0].text;
                return "Sorry, I couldn't think of anything right now.";
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                return "My thoughts are clouded... please try again later.";
            }
        }

        // --- Firebase Auth ---
        function setupAuthListeners() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;
                    authModal.style.display = 'none';
                    await loadGameData();
                    if (!gameInitialized) initGame();
                } else {
                    currentUser = null;
                    authModal.style.display = 'block';
                    document.getElementById('login-view').classList.add('active');
                    document.getElementById('signup-view').classList.remove('active');
                    gameContainer.style.display = 'none';
                    gameInitialized = false;
                }
            });
            
            authToggleLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    const targetId = e.target.dataset.target;
                    document.querySelectorAll('.auth-view').forEach(view => view.classList.remove('active'));
                    document.getElementById(targetId).classList.add('active');
                });
            });

            document.getElementById('login-button').addEventListener('click', () => {
                authError.style.display = 'none';
                const email = document.getElementById('login-email').value;
                const password = document.getElementById('login-password').value;
                signInWithEmailAndPassword(auth, email, password)
                    .catch(error => { authError.textContent = error.message; authError.style.display = 'block'; });
            });

            document.getElementById('signup-button').addEventListener('click', () => {
                authError.style.display = 'none';
                const name = document.getElementById('signup-name').value;
                const age = document.getElementById('signup-age').value;
                const gender = document.getElementById('signup-gender').value;
                const email = document.getElementById('signup-email').value;
                const password = document.getElementById('signup-password').value;

                if (!name || !age || !gender || !email || !password) {
                    authError.textContent = "Please fill out all fields.";
                    authError.style.display = 'block';
                    return;
                }

                createUserWithEmailAndPassword(auth, email, password)
                    .then(async (userCredential) => {
                        const user = userCredential.user;
                        await setDoc(doc(db, "players", user.uid), {
                            name: name,
                            age: parseInt(age),
                            gender: gender,
                            email: user.email,
                            level: 1,
                            totalScore: 0,
                            createdAt: new Date()
                        });
                    })
                    .catch(error => { authError.textContent = error.message; authError.style.display = 'block'; });
            });

            document.getElementById('google-login-button').addEventListener('click', () => {
                authError.style.display = 'none';
                const provider = new GoogleAuthProvider();
                signInWithPopup(auth, provider)
                    .then(async (result) => {
                        const user = result.user;
                        const userDocRef = doc(db, "players", user.uid);
                        const docSnap = await getDoc(userDocRef);
                        if (!docSnap.exists()) {
                             await setDoc(userDocRef, {
                                name: user.displayName,
                                email: user.email,
                                level: 1,
                                totalScore: 0,
                                createdAt: new Date()
                            });
                        }
                    })
                    .catch((error) => {
                        authError.textContent = error.message;
                        authError.style.display = 'block';
                    });
            });
        }

        // --- Firebase Data ---
        async function saveLevelData(levelScore, analysis) {
            if (!currentUser) return;
            totalScore += levelScore;
            const levelDataRef = collection(db, "players", currentUser.uid, "levelData");
            await addDoc(levelDataRef, {
                level: level,
                time: elapsedTime,
                score: levelScore,
                hintsUsed: hintsUsed,
                powerupsCollected: powerupsCollected,
                aiAnalysis: analysis,
                completedAt: new Date()
            });
            await setDoc(doc(db, "players", currentUser.uid), { 
                level: level + 1,
                totalScore: totalScore
            }, { merge: true });
        }

        async function loadGameData() {
            if (!currentUser) return;
            const userDocRef = doc(db, "players", currentUser.uid);
            try {
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    level = data.level || 1;
                    totalScore = data.totalScore || 0;
                    console.log(`Welcome back, ${data.name}! Starting at level ${level} with score ${totalScore}.`);
                } else {
                    console.log("New player document will be created.");
                    level = 1;
                    totalScore = 0;
                }
            } catch (error) {
                console.error("Error loading game data:", error);
                level = 1;
                totalScore = 0;
            }
        }

        // --- Core Game Functions ---
        function initGame() {
            gameContainer.style.display = 'block';
            scene = new THREE.Scene();
            scene.background = createSkybox();
            scene.fog = new THREE.Fog(0x00001a, 50, 150);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            gameContainer.appendChild(renderer.domElement);
            
            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0x4c004c, 2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1.5, 200);
            pointLight.castShadow = true;
            camera.add(pointLight);
            scene.add(camera);
            player = camera;
            wallTexture = createWallTextureAtlas();
            floorTexture = createFloorTexture();
            
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', (e) => keyboard[e.code] = true);
            document.addEventListener('keyup', (e) => keyboard[e.code] = false);
            setupTouchControls();
            
            startButton.addEventListener('click', () => {
                levelCompleteModal.style.display = 'none';
                startLevel();
            });
            hintButton.addEventListener('click', getHint);
            
            gameInitialized = true;
            startLevel();
            animate();
        }

        function startLevel() {
            gameActive = true;
            elapsedTime = 0;
            hintsUsed = 0;
            powerupsCollected = 0;
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                elapsedTime++;
                timeDisplay.textContent = `Time: ${elapsedTime}s`;
            }, 1000);
            levelDisplay.textContent = `Level: ${level}`;
            timeDisplay.textContent = `Time: 0s`;

            // Clear old objects
            if (mazeMesh) { scene.remove(mazeMesh); mazeMesh.geometry.dispose(); mazeMesh.material.dispose(); }
            const oldFloor = scene.getObjectByName("mazeFloor");
            if (oldFloor) { scene.remove(oldFloor); oldFloor.geometry.dispose(); oldFloor.material.dispose(); }
            if (endGoal) { scene.remove(endGoal); if (endGoal.geometry) endGoal.geometry.dispose(); if (endGoal.material) endGoal.material.dispose(); }
            powerups.forEach(p => scene.remove(p));
            powerups = [];

            const mazeSize = 29 + level * 2;
            maze = generateMaze(mazeSize, mazeSize);
            buildMazeMesh();
            placePowerups();
            minimapCanvas.width = maze[0].length * MINIMAP_CELL_SIZE;
            minimapCanvas.height = maze.length * MINIMAP_CELL_SIZE;
            player.position.set(CELL_SIZE, WALL_HEIGHT / 2 - 1, CELL_SIZE);
            player.rotation.set(0, 0, 0);
            playerDirection.set(0, 0, -1);
            endPos = findEndPosition();
            endGoal = createEndGoal(endPos.x, endPos.z);
            scene.add(endGoal);
            hintButton.disabled = false;
        }

        async function nextLevel() {
            gameActive = false;
            hintButton.disabled = true;
            const lastLevelTime = elapsedTime;
            const lastLevel = level;
            
            const levelScore = Math.max(0, Math.round((maze.length * 10) - (lastLevelTime * 2) - (hintsUsed * 25) + (powerupsCollected * POWERUP_SCORE)));
            const newTotalScore = totalScore + levelScore;

            messageTitle.textContent = `Level ${lastLevel} Complete!`;
            messageText.textContent = `Time: ${lastLevelTime}s | Hints: ${hintsUsed} | Powerups: ${powerupsCollected}`;
            scoreText.textContent = `Level Score: +${levelScore}`;
            totalScoreText.textContent = `Total Score: ${newTotalScore}`;
            aiAnalysisText.textContent = '✨ Analyzing performance...';
            levelCompleteModal.style.display = 'block';
            
            const analysisPrompt = `You are an encouraging coach for a brain-training maze game. The player just completed Level ${lastLevel} in ${lastLevelTime} seconds, scored ${levelScore} points, used ${hintsUsed} hints, and collected ${powerupsCollected} powerups. Provide a short, positive, and analytical comment. Focus on concepts like 'focus', 'efficiency', or 'perseverance'. Keep it under 3 sentences.`;
            const analysis = await callGemini(analysisPrompt);
            aiAnalysisText.textContent = analysis;
            
            await saveLevelData(levelScore, analysis);
            level++;
            totalScore = newTotalScore;
        }
        
        function generateMaze(width, height) {
            const maze = Array(height).fill(null).map(() => Array(width).fill(1));
            function carve(x, y) {
                maze[y][x] = 0;
                const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                directions.sort(() => Math.random() - 0.5);
                for (let [dx, dy] of directions) {
                    const nx = x + dx * 2, ny = y + dy * 2;
                    if (ny >= 0 && ny < height && nx >= 0 && nx < width && maze[ny][nx] === 1) {
                        maze[y + dy][x + dx] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            maze[height-2][width-2] = 2;
            return maze;
        }

        function createWallTextureAtlas() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');

            const drawTexture = (x, y, color, pattern) => {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 64, 64);
                ctx.strokeStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.lineWidth = 1;
                
                if (pattern === 'grid') {
                    ctx.beginPath();
                    for (let i = 8; i < 64; i += 8) {
                        ctx.moveTo(x + i, y); ctx.lineTo(x + i, y + 64);
                        ctx.moveTo(x, y + i); ctx.lineTo(x + 64, y + i);
                    }
                    ctx.stroke();
                } else if (pattern === 'circuit') {
                    ctx.beginPath();
                    ctx.moveTo(x, y+32); ctx.lineTo(x+16, y+32); ctx.lineTo(x+16, y+16);
                    ctx.moveTo(x+64, y+16); ctx.lineTo(x+48, y+16); ctx.lineTo(x+48, y+48);
                    ctx.moveTo(x+32, y); ctx.lineTo(x+32, y+16);
                    ctx.moveTo(x+16, y+64); ctx.lineTo(x+16, y+48);
                    ctx.stroke();
                } else if (pattern === 'hex') {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                     for (let i = 0; i < 64; i+= 16) {
                        ctx.strokeRect(x+i, y+i, 8, 8);
                     }
                }
            };
            
            ctx.shadowBlur = 0;
            drawTexture(0, 0, '#1A202C');
            drawTexture(64, 0, '#1A202C', 'circuit');
            drawTexture(0, 64, '#1A202C', 'hex');
            drawTexture(64, 64, '#1A202C', 'grid');

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createFloorTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#00001a';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#9f7aea';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#9f7aea';

            for (let i = 0; i < 512; i += 32) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 512); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(512, i); ctx.stroke();
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createSkybox() {
            const canvases = [];
            for (let i = 0; i < 6; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = 512; canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#00001a';
                ctx.fillRect(0, 0, 512, 512);
                for (let j = 0; j < 400; j++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 512;
                    const radius = Math.random() * 1.5;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
                canvases.push(canvas);
            }
            const cubeTexture = new THREE.CubeTexture(canvases);
            cubeTexture.needsUpdate = true;
            return cubeTexture;
        }

        function buildMazeMesh() {
            const wallGeometries = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    if (maze[y][x] === 1) {
                        const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
                        const quadrant = Math.floor(Math.random() * 4);
                        const uOffset = (quadrant % 2) * 0.5, vOffset = Math.floor(quadrant / 2) * 0.5;
                        const uvs = wallGeo.attributes.uv.array;
                        for (let i = 0; i < uvs.length; i += 2) {
                            uvs[i] = uvs[i] * 0.5 + uOffset;
                            uvs[i+1] = uvs[i+1] * 0.5 + vOffset;
                        }
                        wallGeo.translate(x * CELL_SIZE, WALL_HEIGHT / 2, y * CELL_SIZE);
                        wallGeometries.push(wallGeo);
                    }
                }
            }
            if (wallGeometries.length > 0) {
                const mergedWallGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(wallGeometries, false);
                const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.9, metalness: 0.1 });
                mazeMesh = new THREE.Mesh(mergedWallGeometry, wallMaterial);
                mazeMesh.castShadow = true; mazeMesh.receiveShadow = true; scene.add(mazeMesh);
            }
            
            floorTexture.repeat.set(maze[0].length / 2, maze.length / 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.4, metalness: 0.6 });
            const floorGeo = new THREE.PlaneGeometry(maze[0].length * CELL_SIZE, maze.length * CELL_SIZE);
            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.name = "mazeFloor"; floor.rotation.x = -Math.PI / 2; floor.position.y = 0;
            floor.position.x = (maze[0].length * CELL_SIZE) / 2 - CELL_SIZE / 2;
            floor.position.z = (maze.length * CELL_SIZE) / 2 - CELL_SIZE / 2;
            floor.receiveShadow = true; scene.add(floor);
        }

        function placePowerups() {
            const powerupGeo = new THREE.BoxGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3, CELL_SIZE * 0.3);
            const powerupMat = new THREE.MeshStandardMaterial({ color: 0x9F7AEA, emissive: 0x805AD5, emissiveIntensity: 1.5 });
            
            for (let i = 0; i < POWERUP_COUNT; i++) {
                let placed = false;
                while (!placed) {
                    const x = Math.floor(Math.random() * maze[0].length);
                    const z = Math.floor(Math.random() * maze.length);
                    if (maze[z][x] === 0) {
                        const powerup = new THREE.Mesh(powerupGeo, powerupMat);
                        powerup.position.set(x * CELL_SIZE, WALL_HEIGHT / 2, z * CELL_SIZE);
                        scene.add(powerup);
                        powerups.push(powerup);
                        placed = true;
                    }
                }
            }
        }

        function createEndGoal(x, z) {
            const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.5, CELL_SIZE * 0.5, CELL_SIZE * 0.5);
            const material = new THREE.MeshStandardMaterial({ color: 0x10B981, emissive: 0x059669, emissiveIntensity: 2 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x * CELL_SIZE, WALL_HEIGHT / 2, z * CELL_SIZE);
            const pointLight = new THREE.PointLight(0x10B981, 3, 20);
            cube.add(pointLight);
            return cube;
        }
        
        function findEndPosition() {
            for (let y = maze.length - 1; y >= 0; y--) {
                for (let x = maze[0].length - 1; x >= 0; x--) {
                    if (maze[y][x] === 2) return { x: x, z: y };
                }
            }
            return { x: maze[0].length - 2, z: maze.length - 2 };
        }

        function animate() {
            requestAnimationFrame(animate);
            if (!gameActive || !renderer) return;
            const delta = clock.getDelta();
            updatePlayer(delta);

            const time = Date.now() * 0.002;
            if(endGoal) {
                endGoal.rotation.y += delta * 0.5;
                endGoal.position.y = (WALL_HEIGHT / 2) + Math.sin(time) * 0.5;
            }
            powerups.forEach((p, i) => {
                p.rotation.y += delta * 0.7;
                p.position.y = (WALL_HEIGHT / 2) + Math.sin(time + i) * 0.4;
            });

            drawMinimap();
            renderer.render(scene, camera);
        }

        function updatePlayer(delta) {
            const rotateSpeed = PLAYER_TURN_SPEED * delta;
            let moveDirection = 0, turnDirection = 0;
            if (keyboard['KeyW'] || keyboard['ArrowUp']) moveDirection = 1;
            if (keyboard['KeyS'] || keyboard['ArrowDown']) moveDirection = -1;
            if (keyboard['KeyA'] || keyboard['ArrowLeft']) turnDirection = 1; 
            if (keyboard['KeyD'] || keyboard['ArrowRight']) turnDirection = -1;
            
            if (turnDirection !== 0) {
                player.rotation.y += turnDirection * rotateSpeed;
                playerDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), turnDirection * rotateSpeed);
            }
            
            if (moveDirection !== 0) {
                currentSpeed += PLAYER_ACCELERATION * delta;
                if (currentSpeed > MAX_PLAYER_SPEED) currentSpeed = MAX_PLAYER_SPEED;

                const moveVector = playerDirection.clone().multiplyScalar(currentSpeed * delta * moveDirection);
                const nextPosition = player.position.clone().add(moveVector);
                if (!checkCollision(nextPosition)) {
                    player.position.copy(nextPosition);
                }
            } else {
                currentSpeed = INITIAL_PLAYER_SPEED;
            }
            
            // Check powerup collision
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                if (player.position.distanceTo(powerup.position) < CELL_SIZE / 2) {
                    scene.remove(powerup);
                    powerups.splice(i, 1);
                    powerupsCollected++;
                }
            }

            if (endGoal && player.position.distanceTo(endGoal.position) < CELL_SIZE / 2) {
                nextLevel();
            }
        }
        
        function checkCollision(pos) {
            const checkPoints = [
                new THREE.Vector3(pos.x + PLAYER_RADIUS, pos.y, pos.z + PLAYER_RADIUS),
                new THREE.Vector3(pos.x + PLAYER_RADIUS, pos.y, pos.z - PLAYER_RADIUS),
                new THREE.Vector3(pos.x - PLAYER_RADIUS, pos.y, pos.z + PLAYER_RADIUS),
                new THREE.Vector3(pos.x - PLAYER_RADIUS, pos.y, pos.z - PLAYER_RADIUS)
            ];
            for (const point of checkPoints) {
                const gridX = Math.round(point.x / CELL_SIZE);
                const gridZ = Math.round(point.z / CELL_SIZE);
                if (gridZ < 0 || gridZ >= maze.length || gridX < 0 || gridX >= maze[0].length) return true;
                if (maze[gridZ][gridX] === 1) return true;
            }
            return false;
        }

        function drawMinimap() {
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[0].length; x++) {
                    if (maze[y][x] === 1) minimapCtx.fillStyle = '#4A5568';
                    else if (maze[y][x] === 2) minimapCtx.fillStyle = '#10B981';
                    else minimapCtx.fillStyle = 'rgba(200, 200, 200, 0.1)';
                    minimapCtx.fillRect(x * MINIMAP_CELL_SIZE, y * MINIMAP_CELL_SIZE, MINIMAP_CELL_SIZE, MINIMAP_CELL_SIZE);
                }
            }
            const playerX = player.position.x / CELL_SIZE * MINIMAP_CELL_SIZE;
            const playerZ = player.position.z / CELL_SIZE * MINIMAP_CELL_SIZE;
            minimapCtx.fillStyle = '#00FFFF';
            minimapCtx.beginPath();
            minimapCtx.arc(playerX, playerZ, MINIMAP_CELL_SIZE / 2, 0, 2 * Math.PI);
            minimapCtx.fill();
        }

        async function getHint() {
            hintsUsed++;
            hintButton.disabled = true;
            hintButton.textContent = 'Thinking...';
            
            const playerGridX = Math.round(player.position.x / CELL_SIZE);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE);
            const hintPrompt = `You are a mysterious guide in a 3D maze game. The player is lost and needs a hint. Provide a short, cryptic, and encouraging hint based on their position relative to the exit. Do not give direct instructions like 'go left' or coordinates. Instead, give thematic advice. The player is at (${playerGridX}, ${playerGridZ}) and the exit is at (${endPos.x}, ${endPos.z}). The maze top-left is (0,0).`;
            
            const hint = await callGemini(hintPrompt);
            
            hintDisplay.textContent = hint;
            hintDisplay.style.opacity = '1';
            hintButton.textContent = 'Get Hint ✨';
            
            setTimeout(() => { hintDisplay.style.opacity = '0'; }, 7000);
            setTimeout(() => { if(gameActive) hintButton.disabled = false; }, HINT_COOLDOWN);
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function setupTouchControls() {
            const up = document.getElementById('touch-up'), down = document.getElementById('touch-down'), left = document.getElementById('touch-left'), right = document.getElementById('touch-right');
            const setKey = (key, value) => keyboard[key] = value;
            up.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('ArrowUp', true); }, { passive: false });
            up.addEventListener('touchend', (e) => { e.preventDefault(); setKey('ArrowUp', false); });
            down.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('ArrowDown', true); }, { passive: false });
            down.addEventListener('touchend', (e) => { e.preventDefault(); setKey('ArrowDown', false); });
            left.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('ArrowLeft', true); }, { passive: false });
            left.addEventListener('touchend', (e) => { e.preventDefault(); setKey('ArrowLeft', false); });
            right.addEventListener('touchstart', (e) => { e.preventDefault(); setKey('ArrowRight', true); }, { passive: false });
            right.addEventListener('touchend', (e) => { e.preventDefault(); setKey('ArrowRight', false); });
        }

        // --- Load external scripts and start auth check ---
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js';
        script.onload = () => {
            // Now that BufferGeometryUtils is loaded, we can safely initialize Firebase and the game.
            setupAuthListeners();
        };
        document.head.appendChild(script);
    </script>
</body>
</html>

